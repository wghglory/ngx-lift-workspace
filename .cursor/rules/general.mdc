---
alwaysApply: true
---

# ngx-lift Workspace - General Rules

## Project Overview

This is an **Nx monorepo** containing two Angular libraries: **ngx-lift** and **clr-lift**. This workspace focuses on building reusable Angular utilities and components for the broader Angular community.

- **ngx-lift**: Core Angular utility library (RxJS operators, signal utilities, pipes, validators)
- **clr-lift**: Clarity Design System component library (built on top of ngx-lift)
- **demo**: Demo application showcasing both libraries

Use **Angular 20** best practices, **signals** for state management, **Vitest** for unit tests, and **Playwright** for E2E tests.

## Core Technologies & Versions

- Angular 20
- Nx 22
- VMware Clarity Design System (@clr/angular 17) - clr-lift only
- Vitest 3 for testing
- ESLint 9 with TypeScript ESLint
- Playwright for E2E testing

## Non-Negotiables

- **TypeScript**: Strict mode enabled, DRY principle, no `any` types
- **Library Code**: Build for reusability, maintainability, and tree-shakability
- **Documentation**: All public APIs **must** have JSDoc comments with examples
- **State Management**: Signals for component state; reactive patterns for data flow
- **Testing**: Vitest for unit tests; stable selectors; 60%+ coverage minimum
- **Lifecycle**: No subscriptions in constructor; move initialization logic to `ngOnInit`
- **Accessibility**: ARIA attributes for UI components (clr-lift); keyboard navigation parity
- **UI Components** (clr-lift only): Clarity Angular components; no hard-coded colors

## Code Quality Standards

- **Always** ensure all code passes ESLint without errors or warnings
- **Always** ensure all code is formatted with Prettier
- **Always** ensure TypeScript compilation passes with no errors
- Run `nx lint [project]` before considering work complete
- All generated or modified code must be lint-clean and properly formatted
- Fix or suppress lint warnings only with explicit justification
- **Always** provide JSDoc comments for all exported functions, classes, interfaces, and types

## Definition of Done (Library Development)

- Public APIs have comprehensive JSDoc with examples
- Unit tests (Vitest) written with 60%+ coverage
- TypeScript strict mode passes with no errors
- ESLint clean; Prettier formatted
- No circular dependencies
- Tree-shakable (proper module structure, `sideEffects: false`)
- Peer dependencies properly declared in package.json
- README and CHANGELOG updated (if applicable)
- Demo app showcases the new feature (if applicable)

## File Headers

**Do NOT add copyright headers** to any files in this project. This is an MIT-licensed open-source project.

Unlike corporate/enterprise projects, open-source libraries should not have copyright headers in individual source files. The LICENSE file at the root provides all necessary legal information.

## Performance Guidelines

- **ALWAYS** use `ChangeDetectionStrategy.OnPush` for all components
- **ALWAYS** use `trackBy` functions in `*ngFor` or `track` in `@for` loops
- **ALWAYS** use async pipe for observables in templates (never manual subscriptions)
- Lazy load feature modules and use `@defer` for non-critical components
- **NEVER** call component methods from templates - use pipes or computed signals
- Minimize change detection cycles by using signals and computed values
- Use `runInInjectionContext` when accessing injectors outside constructor/injection context

## TypeScript Guidelines

- Strict mode enabled; no `any` types
- Use type inference where possible; explicit types for public APIs
- Prefer interfaces over types for object shapes (unless unions/intersections needed)
- Use `readonly` for immutable data structures
- Leverage utility types (`Partial`, `Pick`, `Omit`, etc.) for type transformations
- Define proper return types for all functions and methods

## Component Development Guidelines

### ‚öõÔ∏è Reactivity and State Management

- **Reactive Patterns**: Components should use reactive patterns, favoring Angular Signals or Observables for state and data flow
- **Avoid Manual Subscriptions**: Do not use `.subscribe()` calls to update variables for template display. Instead, leverage reactive utilities from libraries like ngx-lift (`computedAsync`, `combineFrom`) to bind data declaratively
- **Signal Inputs**: Use signal inputs (`input()`, `input.required()`) for component inputs instead of `@Input()` decorators
- **Computed Signals**: Use `computed()` for derived state that depends on other signals
- **Effect Usage**: Use `effect()` sparingly and only for side effects (logging, external API calls); avoid DOM manipulation in effects

### üè∑Ô∏è Naming Conventions

- **Async State Suffix**: Any signal created using `createAsyncState` must have a `State` suffix (e.g., `usersState`, `productsState`)
- **Component Files**: Use kebab-case for file names (e.g., `user-profile.component.ts`)
- **Component Classes**: Use PascalCase with descriptive names (e.g., `UserProfileComponent`)
- **Variables/Methods**: Use camelCase (e.g., `userName`, `getUserData()`)
- **Constants**: Use UPPER_SNAKE_CASE (e.g., `MAX_RETRY_COUNT`)
- **Types/Interfaces**: Use PascalCase (e.g., `UserProfile`, `ApiResponse`)

### üé® Styling Guidelines (clr-lift only)

- Use Clarity SASS variables for colors, spacing, typography
- Never hard-code color values (e.g., `#ff0000`, `rgb(255, 0, 0)`)
- Use Clarity utility classes when available
- Custom styles should be scoped to components using `:host` selector
- Follow Clarity design tokens for consistency

### üîß Error Handling

- Use Angular's error handling mechanisms (`ErrorHandler`, `catchError` operator)
- Provide meaningful error messages for library users
- Log errors appropriately (avoid logging sensitive information)
- Handle async errors gracefully using reactive patterns (`catchError`, error signals)

## Unit Testing

- **Framework**: Use Vitest with `@analogjs/vitest-angular`
- **Type Safety**: Avoid `any` types; use proper types or `unknown` with type guards
- **Signal Inputs**: Provide inputs using `fixture.componentRef.setInput()` for components with signal inputs
- **Test Selectors**: Prefer `getByRole` or `data-test-id` attributes for stable selectors
- **Coverage**: Maintain 60% or higher code coverage for all libraries
- **Test Structure**: Follow AAA pattern (Arrange, Act, Assert)
- **Mocking**: Mock external dependencies; use `jest.fn()` for mock functions

## Service & Data Layer Guidelines

- Use `inject()` function for dependency injection (preferred over constructor injection)
- Services should be provided at appropriate levels (root, component, feature)
- Use RxJS operators properly (`map`, `filter`, `switchMap`, `catchError`, etc.)
- Implement proper error handling and retry logic where applicable
- Use async state management patterns for loading/error/success states

## Architecture & Boundaries

- Respect Nx project boundaries; **no circular dependencies**
- Use feature modules to organize related functionality
- Follow Nx library/app structure conventions
- Leverage Nx tags and boundaries for dependency rules
- Use Nx generators for consistent project structure

## Code Review Checklist - TypeScript & Code Quality

Use this checklist when reviewing code changes:

- [ ] No `any` types (use proper types or `unknown`)
- [ ] JSDoc comments for all exported APIs (functions, classes, interfaces, types)
- [ ] Proper return types for functions
- [ ] ESLint/Prettier passes
- [ ] No TypeScript compilation errors
- [ ] No circular dependencies

## Code Review Checklist - Library Development

Use this checklist when reviewing library code:

- [ ] Public APIs have JSDoc with examples
- [ ] Tree-shakable module structure
- [ ] Peer dependencies properly declared
- [ ] 60%+ test coverage
- [ ] Demo app showcases the feature
